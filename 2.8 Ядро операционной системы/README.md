# Домашнее задание к занятию «2.8 Ядро операционной системы»

## Задание 1

При каких событиях выполнение процесса переходит в режим ядра?

Приведите ответ в свободной форме.

### ответ: 

**Аппаратные прерывания** генерируются периферийными устройствами при наступлении определенных событий (например, завершение дисковой операции ввода/вывода или поступление данных на последовательный порт) и имеют асинхронный характер, поскольку невозможно точно сказать, в какой момент наступит то или иное прерывание.

**Особые ситуации** вызваны самим процессом, и связаны с выполнением тех или иных инструкций, например, деление на ноль или обращение к несуществующей странице памяти. Таким образом, обработка особых ситуаций производится в контексте процесса, при этом может использоваться его адресное пространство, а сам процесс — при необходимости блокироваться (перемещаться в состояние сна).

**Системные вызовы** позволяют процессам воспользоваться базовыми услугами ядра. Интерфейс системных вызовов определяет ограниченный набор точек входа в ядро системы, обращение к которым изменяет режим выполнения процесса и позволяет выполнять привилегированные инструкции ядра.

## Задание 2

Найдите имя автора модуля libcrc32c.

В качестве ответа приложите скриншот вывода команды.

### ответ: 

![image](https://user-images.githubusercontent.com/121933872/214323408-561f2124-570a-4576-a402-51e29e67da21.png)

## Задание 3

Используя утилиту strace выясните какой системный вызов использует команда cd.

Примечание: она не является внешним файлом, но для наших целей можно схитрить: strace bash -c 'cd /tmp'. Если вывод кажется слишком перегруженным, подумайте, что можно сделать, чтобы оставить в нём только релевантную информацию?

В качестве ответа напишите название системного вызова.

### ответ: 

chdir

![image](https://user-images.githubusercontent.com/121933872/214324380-59eabc5e-2076-43d7-a7d0-5ba872b8a619.png)


# Дополнительные задания (со звездочкой*)
## Эти задания дополнительные (необязательные к выполнению) и никак не повлияют на получение вами зачета по этому домашнему заданию. Вы можете их выполнить, если хотите глубже и/или шире разобраться в материале.

## Задание 4
Соберите свой модуль и загрузите его в ядро.

Примечание: лучше использовать чистую виртуальную машину, чтобы нивелировать шанс сломать систему.

Установим необходимые пакеты:
apt-get install gcc make linux-headers-$(uname -r)

Создаем файл модуля:
1
2
3
mkdir kmod-hello_world
cd kmod-hello_world/
touch ./mhello.c
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
#define MODULE
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPLv3");

int init_module(void){
    printk("<1> Hello,World\n");
    return 0;
}

void cleanup_module(void){
    printk("<1> Goodbye.\n");
}
Создаем Makefile: touch ./Makefile
1
2
3
4
5
6
7
8
9
obj-m += mhello.o

hello-objs := mhello.c

all:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean
Обратите внимание, что отступы перед make - это табуляция, а не пробелы. Для синтаксиса Makefile это важно.

Собираем модуль и устанавливаем его с помощью insmod.
1
2
make all
insmod path/to/module.ko
В качестве ответа приложите скриншот вывода установки модуля в dmesg


### ответ: 
